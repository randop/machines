-- # dnsdist meta:v2.0.0
setLocal("0.0.0.0:53")

newServer({address="127.0.0.1:5301", pool="default"})
newServer({address="127.0.0.1:5300", pool="kubernetes"})

-- reusable actions
blk = SpoofAction("0.0.0.0")
kube = PoolAction("kubernetes")

-- #=================================================================
-- Filter Rules: ALLOW
-- #================================================================
addAction(makeRule("tindango"), kube)
addAction("*.tindango", kube)
addAction(makeRule("localdomain"), kube)
addAction("*.localdomain", kube)
addAction(makeRule("localservice"), kube)
addAction("*.localservice", kube)

addAction(AllRule(), PoolAction("default"))

-- high-performance cache
local pc = newPacketCache(                 -- parameters tuned for heavy load
  1000000,                 -- max cached entries
  {
    maxTTL = 86400,        -- cap cached TTL at 1 day (equal to actual record TTL)
    minTTL = 0,            -- allow very short records
    temporaryFailureTTL = 60,   -- SERVFAIL / timeouts
    staleTTL = 60,              -- use stale data while upstream still down
    dontAge = false,            -- age entries normally
    maxNegativeTTL = 3600       -- cap NODATA / NXDOMAIN TTL
  })

-- attach cache with default downstream dns
getPool("default"):setCache(pc)

-- #=================================================================
-- Filter Rules: BLOCK
-- #=================================================================
-- # exact-match domain
-- addAction(makeRule("microsoft.com"), SpoofAction())
-- # any sub-domain
-- addAction("*.microsoft.com", SpoofAction())
addAction(makeRule("microsoft.com"), blk)
addAction("*.microsoft.com", blk)
addAction(makeRule("apple.com"), blk)
addAction("*.apple.com", blk)
addAction(makeRule("google.com"), blk)
addAction("*.google.com", blk)
addAction(makeRule("facebook.com"), blk)
addAction("*.facebook.com", blk)
addAction(makeRule("youtube.com"), blk)
addAction("*.youtube.com", blk)
addAction(makeRule("googleapis.com"), blk)
addAction("*.googleapis.com", blk)
addAction(makeRule("gstatic.com"), blk)
addAction("*.gstatic.com", blk)
addAction(makeRule("googlezip.net"), blk)
addAction("*.googlezip.net", blk)
addAction(makeRule("googlevideo.com"), blk)
addAction("*.googlevideo.com", blk)

function makeQueryRestartable(dq)
  -- make it possible to restart that query later
  -- by keeping a copy of the initial DNS payload around
  dq:setRestartable()
  return DNSAction.None
end

addAction(AllRule(), LuaAction(makeQueryRestartable))

-- # Important to handle ->>HEADER<<- opcode: QUERY, status: NXDOMAIN from downstream
function nxDomainPolicy(dr)
  if dr.rcode == DNSRCode.NXDOMAIN and dr.pool ~= 'restarted' then
    -- assign this query to a new pool
    dr.pool = 'restarted'
    -- discard the received response and
    -- restart the processing of the query
    dr:restart()
    dr.rcode = DNSRCode.NOERROR
    return DNSResponseAction.Truncate
  end

  return DNSResponseAction.None
end


addResponseAction(AllRule(), LuaResponseAction(nxDomainPolicy))

function nxFallbackPolicy(dr)
  if dr.rcode == DNSRCode.NOERROR and dr.pool == 'restarted' then
    dr:restart()
    dr.pool = 'fallback'
    dr.rcode = DNSRCode.NOERROR
    dr:setTag('fallback', 'fallback')
    return DNSResponseAction.None
  end

  return DNSResponseAction.None
end

addResponseAction(AllRule(), LuaResponseAction(nxFallbackPolicy))

-- # TODO: spoof answer
-- # [dnsdist] Feature Request: Allows using SpoofAction in DNSResponse
-- # https://github.com/PowerDNS/pdns/issues/14821
function spoofPolicy(dr)
  dr:restart()
  dr:setTag('spoof', 'spoof')
  return DNSResponseAction.Truncate
end

addResponseAction(TagRule('fallback'), LuaResponseAction(spoofPolicy))

